```
>>===============================================================================<<
|| ▄█          ▄████████     ███             ▄▄▄▄███▄▄▄▄   ███    █▄      ███    ||
||███         ███    ███ ▀█████████▄       ▄██▀▀▀███▀▀▀██▄ ███    ███ ▀█████████▄||
||███         ███    █▀     ▀███▀▀██       ███   ███   ███ ███    ███    ▀███▀▀██||
||███        ▄███▄▄▄         ███   ▀       ███   ███   ███ ███    ███     ███   ▀||
||███       ▀▀███▀▀▀         ███           ███   ███   ███ ███    ███     ███    ||
||███         ███    █▄      ███           ███   ███   ███ ███    ███     ███    ||
||███▌    ▄   ███    ███     ███           ███   ███   ███ ███    ███     ███    ||
||█████▄▄██   ██████████    ▄████▀          ▀█   ███   █▀  ████████▀     ▄████▀  ||
||▀                                                                              ||
|| ▄█      ███          ▀█████████▄     ▄████████                                ||
||███  ▀█████████▄        ███    ███   ███    ███                                ||
||███▌    ▀███▀▀██        ███    ███   ███    █▀                                 ||
||███▌     ███   ▀       ▄███▄▄▄██▀   ▄███▄▄▄                                    ||
||███▌     ███          ▀▀███▀▀▀██▄  ▀▀███▀▀▀                                    ||
||███      ███            ███    ██▄   ███    █▄                                 ||
||███      ███            ███    ███   ███    ███                                ||
||█▀      ▄████▀        ▄█████████▀    ██████████                                ||
>>===============================================================================<<
```

# Строки
Этих всех проблем могло и не быть, если бы по стандарту в си у строк хранилась их длина. Тогда strlen() отрабатывал бы за O(1).

На самом деле, такие строки существуют - это pascal-строки. Но давайте по порядку, для полноты доклада расскажу о C-строках, или нуль терминированных строках.

## Строки с нуль терминатором
|'H'|'e'|'l'|'l'|'o'|' '|'W'|'o'|'r'|'l'|'d'| 0 |

В этом случае строки представляют собой последовательность символов, оканчивающихся нулевым байтом. В качестве значения в вычислениях используется указатель на первый символ в строке.

Некоторые преимущества такого представления:
* Отсутствие дополнительной информации о свойствах строки
* Отсутствие ограничения на максимальный размер строки (как будто это кому-нибудь нужно...)
* Простое получение суффикса строки

Недостатки:
* Отсутствие дополнительной информации о свойствах строки
* Получение длины строки за полный проход строки
* Долгая конкатенация
* Легко все поломать, если повредить нуль терминатор

## Паскаль строки
| 11 |**'H'**|**'e'**|**'l'**|**'l'**|**'o'**|**' '**|**'W'**|**'o'**|**'r'**|**'l'**|**'d'**|'a'|'b'|'o'|'b'|'a'|

В данном случае все еще в вычислениях используется указатель на строку, но уже не на начало строки, а на число, сразу за которым начинается последовательность символов. Это число - это длина строки.

Преимущества:
* Получение размера строки за O(1)
* Строка может содержать любые символы
* Безопасность

Недостатки:
* Ограничение максимального размера строки (как будто кто-нибудь когда-нибудь выйдет за пределы...)
* Если храним символы переменной длины, то в начале хранится уже не длина строки, а просто количество байтов. Длину придется считать вручную

## Два указателя
|120|121|122|123|124|125|126|127|128|129|130|131|132|133|134|135|136|

|'n'|'n'|'g'|**'H'**|**'e'**|**'l'**|**'l'**|**'o'**|**' '**|**'W'**|**'o'**|**'r'**|**'l'**|**'d'**|'a'|'b'|'c'|

```c
struct string {
    char* addr;
    size_t len;
};

struct string s = {
    .addr = 123,
    .len = 11,
};
```

Преимущества:
* Все те же, что и у паскалевых строк
* Можно взять срез строки за O(1). Не нужно производить лишних копирований

Недостатки:
* Структура занимает больше места, чем просто указатель

## Неизменяемые строки
Давайте подойдем к рассмотрению строк немного с другой стороны. Что, если наши строки неизменяемые? Какие преимущества это принесет?

Во-первых, в таком случае мы обеспечиваем безопасность. Мы можем быть уверены, что строка не будет изменена в какой-нибудь функции без нашего ведома. Более того, мы можем спокойно использовать одну строку между потоками.

Во-вторых, к таким строкам можно применить механизм интернирования. Это когда в программе есть единый пул строк. В таком случае можно: 
* За O(1) производить сравнения, ведь сравниваются только ссылки
* За O(1) производить копирование, ведь все, что нужно сделать - это просто скопировать адрес

Конечно, такое в общем случае подходит только для статических строк. Впрочем в некоторых языках есть механизмы, позволяющие производить динамическое интернирование строк.